{"./":{"url":"./","title":"Ningbo Zhao","keywords":"","body":"Ningbo Zhao 目前工作于美团出行，负责数据平台和商业模型。LinkedIn / ningincn#hotmail.com 用 yuque2book + github page 搭建了此博客，用来记录学习笔记。 方向：统计学、数据分析、机器学习、可视化。技术：SQL、Hive、Shell、Python(numpy,pandas,plotly,sklearn,scipy)、Jupyter Notebook 一些可视化作品： © NingboZhao 2019 all right reserved，powered by GitbookUpdate： 2019-05-23 14:10:30 "},"datascience.html":{"url":"datascience.html","title":"数据科学知识模型","keywords":"","body":"数据科学知识模型 模拟服务端数据 在前面的章节中，我们设置了代理，于是所有的 HTTP 请求都可以先到达本地开发服务器，再被转发。在实际的开发中，后端的服务不一定马上可用，这就需要本地服务器另外一个能力：模拟数据（mock）。设置代理是 mock 的前提。 一个 ajax 请求发送到本地开发服务器后，我们可以设置：如果请求满足某个规则，则不转发这个请求，而是直接返回一个「假」结果给浏览器。在实际的开发中，我们常常先和服务端的同学商定 http 请求的接口接受什么参数，返回什么结果，然后先用 mock 数据来模拟，自己和自己「联调」。等待服务端同学开发好了，再解除 mock，用真实数据「联调」。 模拟正常返回数据 设置模拟数据时需要在工程根目录下的 mock 子目录中的建立文件。首先在工程中增加 mock 目录，并在其中创建文件 puzzlecards.js（取其他名字也可以，名字这里不需要）。如果想 mock 掉我们在上一个章节中的向 /dev/random_joke 的 ajax 调用，需要写入以下内容到文件， const random_jokes = [ { setup: 'What is the object oriented way to get wealthy ?', punchline: 'Inheritance', }, { setup: 'To understand what recursion is...', punchline: \"You must first understand what recursion is\", }, { setup: 'What do you call a factory that sells passable products?', punchline: 'A satisfactory', }, ]; let random_joke_call_count = 0; export default { 'get /dev/random_joke': function (req, res) { const responseObj = random_jokes[random_joke_call_count % random_jokes.length]; random_joke_call_count += 1; setTimeout(() => { res.json(responseObj); }, 3000); }, }; 如果你不断地刷新页面，会发现每次拿到的数据是不同的。并且由于 setTimeout 的存在使得卡片的更新变慢了。 我们通过这个例子解释一下怎么写 mock 数据。 首先，整个文件需要 export 出一个 js 对象。对象的 key 是由 构成的，值是 function，当一个 ajax 调用匹配了 key 后，与之对应的 function 就会被执行。函数中我们调用 res.json 就可以给浏览器返回结果。函数中可以使用 setTimeout 来模拟异步调用服务时的时延。 模拟出错 利用 res.status 也可以模拟 http 请求出错。例如，我们把文件中的 export default 块替换成下面的内容， export default { 'get /dev/random_joke': function (req, res) { res.status(500); res.json({}); }, }; 在 dva model 中我们加入简单的错误捕获: import { message } from 'antd'; // ... 原有逻辑不修改 try { // 加入 try catch 捕获抛错 const puzzle = yield call(request, endPointURI); yield put({ type: 'addNewCard', payload: puzzle }); yield call(delay, 3000); const puzzle2 = yield call(request, endPointURI); yield put({ type: 'addNewCard', payload: puzzle2 }); } catch (e) { message.error('数据获取失败'); // 打印错误信息 } 于是可以看到出错状况下的页面： 在每一个调用点做打印错误信息很麻烦，这里只是为了展示 mock 出错场景。在实际的开发中，一般会统一处理 http 请求错误时的信息提示。 简单数据模拟 刚才的模拟中，mock 具备动态改变、延时返回等能力，如果你不需要这个能力，也可以简单地使用对象。 export default { 'get /dev/random_joke': { setup: 'What is the object oriented way to get wealthy ?', punchline: 'Inheritance', }, }; 深入理解 umi 本文介绍 umi 框架的一些深入概念，帮助大家理解背后的运行机制。 下图是 umi 的架构图，我们试着从此图来一步步理解 umi 。 基于路由 举个 SPA 的例子，比如我们访问 /users，会由 ./src/pages/users.js 决定具体渲染什么，按我们的理解，这其中 /users 是路由，./src/pages/users.js 是路由组件，他们俩组成了一个路由配置，然后多个路由配置又形成了一个完整的应用。不难发现，在这个应用里，路由即入口。 umi 是基于路由的，所以具备了管理入口的能力。你甚至可以简单地理解为 umi = 路由 + webpack，当然我们在此基础上做了很多额外的工作。然后，管理了入口之后，能做的事情就很多了。 比如： 开发时按需编译 运行时按需加载，做 code-splitting 智能提取公共代码，加速用户访问，通常是被 路由数/2 引用的模块才被提取到公共代码中 服务端渲染 基于路由的埋点 基于约定，如果 ./src/pages/404.js 存在则添加为 fallback 路由 ... 这里有很大的想象空间。 从源码到上线的生命周期管理 市面上的框架基本都是从源码到构建产物，很少会考虑到各种发布流程，而 umi 则多走了这一步。 下图是 umi 从源码到上线的一个流程。 umi 首先会加载用户的配置和插件，然后基于配置或者目录，生成一份路由配置，再基于此路由配置，把 JS/CSS 源码和 HTML 完整地串联起来。用户配置的参数和插件会影响流程里的每个环节。 举个例子，比如以下目录： + src + layouts/index.js + pages - a.js - b.js - 404.js 会生成路由配置如下： { component: 'layouts/index.js', routes: [ { path: '/a', exact: true, component: 'pages/a.js' }, { path: '/b', exact: true, component: 'pages/b.js' }, { component: 'pages/404.js' }, ], } 以及可运行的代码： const routes = { component: require('layouts/index.js'), routes: [ { path: '/a', exact: true, component: require('pages/a.js') }, { path: '/b', exact: true, component: require('pages/b.js') }, { component: require('pages/404.js') }, ], }; export default () => { renderRoutes(routes) } 另外，HTML 也是一个很重要的环节，因为他才是真正的入口，js 和 css 都是在 HTML 里发起的。HTML 在 umi 里是一等公民，这意味着我们可以通过插件来调整他的输出，以便和各个后台系统对接，以及打通各种发布流程。 举个例子，我们要配置 webpack externals 掉 react 来优化构建产物，通常我们要做两步： 配置 externals: { react: 'window.React' } 在 html 里引入 https://unpkg.com/react@16.4.1/cjs/react.production.min.js 这里的问题是一个功能需要在两个地方维护并且一一对应。然后在 umi 里，由于 HTML 具备插件的能力，所以可以做到你只需要完成第一步，然后 umi 自动帮你做第二步。 最后，通过 umi 可以把各种部署方式封装成插件，实现同一份源码，装载不同的插件，就可以部署到不同平台。比如 umi + umi-plugin-deploy-offline 可以部署为离线包；umi + umi-plugin-deploy-chair 可以部署到 chair 系统。 插件机制 关于 umi 的插件机制你可以阅读 umi 的文档《插件开发》来了解更多。 © NingboZhao 2019 all right reserved，powered by GitbookUpdate： 2019-06-24 16:01:35 "},"Python/Python对象类型.html":{"url":"Python/Python对象类型.html","title":"Python 对象类型","keywords":"","body":"Python 对象类型 © NingboZhao 2019 all right reserved，powered by GitbookUpdate： 2019-05-23 14:30:12 "},"Python/PandasCheatSheet.html":{"url":"Python/PandasCheatSheet.html","title":"Pandas Cheat Sheet","keywords":"","body":"Pandas Cheat Sheet © NingboZhao 2019 all right reserved，powered by GitbookUpdate： 2019-05-23 14:30:12 "},"Shell/shellbase.html":{"url":"Shell/shellbase.html","title":"Shell 基础","keywords":"","body":"Shell 基础 © NingboZhao 2019 all right reserved，powered by GitbookUpdate： 2019-05-23 14:30:12 "},"Hadoop/Hive时间函数.html":{"url":"Hadoop/Hive时间函数.html","title":"Hive 时间函数","keywords":"","body":"Hive 时间函数 © NingboZhao 2019 all right reserved，powered by GitbookUpdate： 2019-05-23 14:30:12 "},"SQL/MySQL系统操作函数.html":{"url":"SQL/MySQL系统操作函数.html","title":"MySQL 系统操作函数","keywords":"","body":"MySQL 系统操作函数 © NingboZhao 2019 all right reserved，powered by GitbookUpdate： 2019-05-23 14:30:12 "},"Jupyter/在Mac上配置.html":{"url":"Jupyter/在Mac上配置.html","title":"在 Mac 上配置","keywords":"","body":"在 Mac 上配置 © NingboZhao 2019 all right reserved，powered by GitbookUpdate： 2019-05-23 14:30:12 "},"Jupyter/拓展和小工具.html":{"url":"Jupyter/拓展和小工具.html","title":"拓展和小工具","keywords":"","body":"拓展和小工具 © NingboZhao 2019 all right reserved，powered by GitbookUpdate： 2019-05-23 14:30:12 "},"Leecode/185.html":{"url":"Leecode/185.html","title":"185. 部门工资前三高的员工","keywords":"","body":"185. 部门工资前三高的员工 © NingboZhao 2019 all right reserved，powered by GitbookUpdate： 2019-05-23 14:30:12 "},"Leecode/601.html":{"url":"Leecode/601.html","title":"601. 体育馆的人流量","keywords":"","body":"601. 体育馆的人流量 © NingboZhao 2019 all right reserved，powered by GitbookUpdate： 2019-05-23 14:30:12 "},"思维训练/金字塔原理.html":{"url":"思维训练/金字塔原理.html","title":"金字塔原理","keywords":"","body":"金字塔原理 © NingboZhao 2019 all right reserved，powered by GitbookUpdate： 2019-05-23 14:30:12 "},"思维训练/结构化思维.html":{"url":"思维训练/结构化思维.html","title":"结构化思维","keywords":"","body":"结构化思维 © NingboZhao 2019 all right reserved，powered by GitbookUpdate： 2019-05-23 14:30:12 "},"思维训练/迭代.html":{"url":"思维训练/迭代.html","title":"迭代","keywords":"","body":"迭代 © NingboZhao 2019 all right reserved，powered by GitbookUpdate： 2019-05-23 14:30:12 "},"Sis/统计学基础.html":{"url":"Sis/统计学基础.html","title":"统计学基础","keywords":"","body":"统计学基础 © NingboZhao 2019 all right reserved，powered by GitbookUpdate： 2019-05-23 14:30:12 "},"Sis/描述统计.html":{"url":"Sis/描述统计.html","title":"描述统计","keywords":"","body":"描述统计 © NingboZhao 2019 all right reserved，powered by GitbookUpdate： 2019-05-23 14:30:12 "},"Sis/时间序列：统计学理论.html":{"url":"Sis/时间序列：统计学理论.html","title":"时间序列：统计学理论","keywords":"","body":"时间序列：统计学理论 传统方法：简单平均法、移动平均法、指数平滑法等现代方法：Box-Jenkins 的自回归模型（ARMA）ML 方法：LBGM，XGBoost，小波变换+SVM，LSTM，Prophet等 〇、导论 时间序列预测关键：确定已有的时间序列的变化模式，并假定这种模式会延续到未来。时间序列数据用于描述现象随时间发展变化的特征。 时间序列预测法的基本特点 假设事物发展趋势会延伸到未来 预测所依据的数据具有不规则性 不考虑事物发展之间的因果关系 一、时间序列及其分解 1. 平稳序列（stationary series） 基本上不存在趋势的序列，序列中的各观察值基本上在某个固定的水平上波动，在不同时间段波动程度不同，但不存在某种规律，随机波动 2. 非平稳序列（non-stationary series） 是包含趋势、季节性或周期性的序列，只含有其中一种成分，也可能是几种成分的组合。可分为：有趋势序列、有趋势和季节性序列、几种成分混合而成的复合型序列。 趋势（trend）：时间序列在长时期内呈现出来的某种持续上升或持续下降的变动，也称长期趋势。时间序列中的趋势可以是线性和非线性。 季节性（seasonality）：季节变动（seasonal fluctuation）,是时间序列在一年内重复出现的周期波动。销售旺季，销售淡季，旅游旺季、旅游淡季，因季节不同而发生变化。季节，不仅指一年中的四季，其实是指任何一种周期性的变化。含有季节成分的序列可能含有趋势，也可能不含有趋势。 除此之外，还有偶然性因素对时间序列产生影响，致使时间序列呈现出某种随机波动。时间序列除去趋势、周期性和季节性后的偶然性波动，称为随机性（random），也称不规则波动（irregular variations）。时间序列的成分可分为4种：趋势（T）、季节性或季节变动（S）、周期性或循环波动（C）、随机性或不规则波动（I）。传统时间序列分析的一项主要内容就是把这些成分从时间序列中分离出来，并将它们之间的关系用一定的数学关系式予以表达，而后分别进行分析。按4种成分对时间序列的影响方式不同，时间序列可分解为多种模型：加法模型（additive model），乘法模型（multiplicative model）。乘法模型： 二、描述性分析 1. 增长率 增长速度，是时间序列中报告期观察值与基期观察值之比减1后的结果，用%表示。由于对比的基期不同，可分为环比增长率和定基增长率。 环比增长率：是报告期观察值与前一时期观察值之比减1，说明现象逐期增长变化的程度；定基增长率：报告期观察值与某一固定时期观察值之比减1，说明现象在整个观察期内总的增长变化程度。 2. 平均增长率 平均增长速度，是时间序列中逐期环比值（环比发展速度）的几何平均数减1的结果 3. 增长率分析中应注意的问题 i: 当时间序列中的观察出现0或负数时，不宜计算增长率。这种序列计算增长率，要么不符合数学公理，要么无法解释其实际意义。可用绝对数进行分析。ii: 有些情况下，不能单纯就增长率论增长率，注意增长率与绝对水平结合起来。增长率是一个相对值，与对比的基数值的大小有关。这种情况，计算增长1%的绝对值来克服增长率分析的局限性：增长1%的绝对值表示增长率每增长一个百分点而增加的绝对数量：增长1%的绝对值=前期水平/100 三、时间序列预测的程序 时间序列分析的主要目的之一是根据已有的历史数据对未来进行预测。时间序列含有不同的成分，如趋势、季节性、周期性和随机性。对于一个具体的时间序列，它可能含有一种成分，也可能同时含有几种成分，含有不同成分的时间序列所用的预测方法是不同的。预测步骤：第一步：确定时间序列所包含的成分，确定时间序列的类型第二步：找出适合此类时间序列的预测方法第三步：对可能的预测方法进行评估，以确定最佳预测方案第四步：利用最佳预测方案进行预测 1. 确定时间序列成分 （1）确定趋势成分 确定趋势成分是否存在，可绘制时间序列的线图，看时间序列是否存在趋势，以及存在趋势是线性还是非线性。利用回归分析拟合一条趋势线，对回归系数进行显著性检验。回归系数显著，可得出线性趋势显著的结论。 （2）确定季节成分 确定季节成分是否存在，至少需要两年数据，且数据需要按季度、月份、周或天来记录。可绘图，年度折叠时间序列图（folded annual time series plot），需要将每年的数据分开画在图上，横轴只有一年的长度，每年的数据分别对应纵轴。如果时间序列只存在季节成分，年度折叠时间序列图中的折线将会有交叉；如果时间序列既含有季节成分又含有趋势，则年度折叠时间序列图中的折线将不会有交叉，若趋势上升，后面年度的折线将会高于前面年度的折线，若下降，则后面年度的折线将会低于前面年度的折线。 2、选择预测方法 确定时间序列类型后，选择适当的预测方法。利用时间数据进行预测，通常假定过去的变化趋势会延续到未来，这样就可以根据过去已有的形态或模式进行预测。时间序列的预测方法：传统方法：简单平均法、移动平均法、指数平滑法等，现代方法：Box-Jenkins 的自回归模型（ARMA）。 一般来说，任何时间序列都会有不规则成分存在，在商务和管理数据中通常不考虑周期性，只考虑趋势成分和季节成分。 不含趋势和季节成分的时间序列，即平稳时间序列只含随机成分，只要通过平滑可消除随机波动。因此，这类预测方法也称平滑预测方法。 3、预测方法的评估 在选择某种特定的方法进行预测时，需要评价该方法的预测效果或准确性。评价方法是找出预测值与实际值的差距，即预测误差。最优的预测方法就是预测误差达到最小的方法。预测误差计算方法：平均误差，平均绝对误差、均方误差、平均百分比误差、平均绝对百分比误差。方法的选择取决于预测者的目标、对方法的熟悉程度。 （1）平均误差（mean error） Y:观测值，F：预测值，n预测值个数由于预测误差的数值可能有正有负，求和的结果就会相互抵消，这种情况下，平均误差可能会低估误差。 （2）平均绝对误差（mean absolute deviation） 是将预测误差取绝对值后计算的平均无擦，MAD：平均绝对误差可避免误差相互抵消的问题，因而可以准确反映实际预测误差的大小。 （3）均方误差（mean square error） 通过平方消去误差的正负号后计算的平均误差，MSE: （4）平均百分比误差和平均绝对百分比误差 ME,MAD,MSE的大小受时间序列数据的水平和计量单位的影响，有时并不能真正反映预测模型的好坏，只有在比较不同模型对同一数据的预测时才有意义。平均百分比误差（mean percentage error，MPE）和平均绝对百分比误差（mean absolute percentage error,MAPE）则不同，它们消除了时间序列数据的水平和计量单位的影响，是反映误差大小的相对值。 4、平稳序列的预测 平稳时间序列只含有随机成分，预测方法：简单平均法、移动平均法、指数平滑法。主要通过对时间序列进行平滑以消除随机波动，又称平滑法。平滑法可用于对时间序列进行短期预测，也可对时间序列进行平滑以描述序列的趋势（线性趋势和非线性趋势）。 1. 简单平均法 2. 移动平均法 3. 指数平滑法 5、趋势型序列的预测 时间序列的趋势可分为线性趋势和非线性趋势，若这种趋势能够延续到未来，就可利用趋势进行外推预测。有趋势序列的预测方法主要有线性趋势预测、非线性趋势预测和自回归模型预测。 1. 线性趋势预测 线性趋势（linear trend）是指现象随着时间的推移而呈现稳定增长或下降的线性变化规律。 2. 非线性趋势预测 序列中的趋势通常可认为是由于某种固定因素作用同一方向所形成的。若这种因素随时间推移按线性变化，则可对时间序列拟合趋势直线；若呈现出某种非线性趋势（non-linear trend）,则需要拟合适当的趋势曲线。 2.1：指数曲线（exponential curve） ** 2.2：指数曲线（exponential curve） 6、复合型序列的分解预测 复合型序列是指含有趋势、季节、周期和随机成分的序列。对这类序列的预测方法是将时间序列的各个因素依次分解出来，然后进行预测。由于周期成分的分析需要有多年的数据，实际中很难得到多年的数据，因此采用的分解模型为：预测方法有：季节性多元回归模型、季节自回归模型和时间序列分解法预测。 分解法预测步骤：第一步：确定并分离季节成分。计算季节指数，以确定时间序列中的季节成分。然后将季节成分从时间序列中分离出去，即用每一个时间序列观察值除以相应的季节指数，以消除季节性。第二步：建立预测模型并进行预测。对消除了季节成分的时间序列建立适当的预测模型，并根据这一模型进行预测。第三步：计算最后的预测值。用预测值乘以相应的季节指数，得到最终的预测值。 1. 确定并分离季节成分 季节性因素分析是通过季节指数来表示各年的季节成分，以此描述各年的季节变动模式。 1.1 计算季节指数（seasonal index） 季节指数刻画了序列在一个年度内各月或各季度的典型季节特征。在乘法模型中，季节指数以其平均数等于100%为条件而构成的，反映了某一月份或季度的数值占全年平均值的大小。若现象的发展没有季节变动，则各期的季节指数应等于100%；若某一月份或季度有明显的季节变化，则各期的季节指数应大于或小于100%。因此，季节变动的程度是根据各季节指数与其平均数（100%）的偏差程度来测定的。季节指数计算方法较多，移动平均趋势剔除法步骤：第一步：计算移动平均值（若是季节数据，采用4项移动平均，月份数据则采用12项移动平均），并对其结果进行中心化处理，即将移动平均的结果再进行一次二项移动平均，即得出中心化移动平均值（CMA）。第二步：计算移动平均的比值，即季节比率，即将序列的各观察值除以相应的中心化移动平均值，然后计算出各比值的季度或月份平均值。第三步：季节指数调整。由于各季节指数的平均数应应等于1或100%，若根据第二步计算的季节比率的平均值不等于1，则需要进行调整。具体方法：将第二步计算的每个季节比率的平均值除以它们的总平均值。 1.2 分离季节成分 计算出季节指数后，可将各实际观察值分别除以相应的季节指数，将季节成分从时间序列中分离出去：结果即为季节成分分离后的序列，反映了在没有季节因素影响下时间序列的变化形态。 2 建立预测模型并进行预测 朴素估计 使用最后一个时间点的值估测后面一段时间段的值。 简单平均法 使用之前一定大小时间段的平均值作为这个时间点的值。 移动平均法 指数平滑法 © NingboZhao 2019 all right reserved，powered by GitbookUpdate： 2019-05-23 17:08:36 "},"ML/朴素贝叶斯.html":{"url":"ML/朴素贝叶斯.html","title":"朴素贝叶斯","keywords":"","body":"朴素贝叶斯 © NingboZhao 2019 all right reserved，powered by GitbookUpdate： 2019-05-23 14:30:12 "},"ML/主成分分析PCA.html":{"url":"ML/主成分分析PCA.html","title":"主成分分析 PCA","keywords":"","body":"主成分分析 PCA © NingboZhao 2019 all right reserved，powered by GitbookUpdate： 2019-05-23 14:30:12 "},"ML/K-means聚类：理论.html":{"url":"ML/K-means聚类：理论.html","title":"K-means 聚类:理论","keywords":"","body":"K-means 聚类:理论 © NingboZhao 2019 all right reserved，powered by GitbookUpdate： 2019-05-23 14:30:12 "},"Dataviz/Awesome_dataviz.html":{"url":"Dataviz/Awesome_dataviz.html","title":"Awesome dataviz","keywords":"","body":"Awesome dataviz © NingboZhao 2019 all right reserved，powered by GitbookUpdate： 2019-05-23 14:30:12 "},"Dataviz/结构化思维.html":{"url":"Dataviz/结构化思维.html","title":"Tableau","keywords":"","body":"Tableau © NingboZhao 2019 all right reserved，powered by GitbookUpdate： 2019-05-23 14:30:12 "},"Dataviz/迭代.html":{"url":"Dataviz/迭代.html","title":"PyEcharts","keywords":"","body":"PyEcharts © NingboZhao 2019 all right reserved，powered by GitbookUpdate： 2019-05-23 14:30:12 "}}